---
title: 쿠버네티스(Kubernetes) 아키텍처 간단 정리
description: 컨테이너를 쉽게 배포하고 관리할 수 있게 해주는 시스템인 쿠버네티스(Kubernetes)에 대해서 알아봅시다.
date: "2020-09-14T21:30:00.000Z"
template: post
slug: "understanding-basic-kubernetes-architecture"
category: DevOps
tags:
  - DevOps
  - Kubernetes
  - Docker
socialImage: "/media/kubernetes.png"
---

쿠버네티스는 컨테이너 시스템 상에서 컨테이너를 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템입니다. 개발자가 특정 인프라 관련 서비스를 애플리케이션에서 구현하지 않아도 되며 여기에는 서비스 디스커버리, 오토스케일링, 로드 밸런싱, 자가 치유 등이 포함됩니다.

## 쿠버네티스 클러스터 아키텍처

쿠버네티스는 크게 두 가지 유형의 노드로 구성됩니다.

- 마스터 노드
  - 전체 쿠버네티스 시스템을 관리하고 통제하는 `컨트롤 플레인(Control Plan)` 을 관장합니다.
- 워커 노드
  - 실제 배포하고자 하는 어플리케이션의 실행을 담당합니다.

![https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

## 컨트롤 플레인(마스터 노드)

컨트롤 플레인(마스터 노드)은 클러스터를 관리하고 특정 기능을 실행하며, 다음과 같은 구성요소를 포함하고 있습니다.

- `API Server` - 사용자와 컨트롤 플레인이 통신하는 쿠버네티스 API 서버
- `Scheduler` - 애플리케이션을 워커 노드에 할당하는 스케줄러
- `Controller Manager` - 구성 요소 복제, 워커 노드 추적, 노드 장애 처리 등 클러스터 수준의 기능을 실행하는 컨트롤러 매니저
- `etcd` - 클러스터 구성을 지속적으로 저장하는 분산 데이터 스토리지

## 워커 노드

워커 노드는 애플리케이션의 실행을 담당하는 시스템입니다. 워커노드는 다음과 같은 구성요소를 포함하고 있습니다.

- 컨테이너를 실행하는 도커 또는 컨테이너 런타임
- `Kuberlet` - API Server 와 통신하고 노드에서 컨테이너를 관리
- `kube-proxy` - 애플리케이션 구성 요소 간에 네트워크 트래픽을 분산하는 쿠버네티스 서비스 프록시

## 쿠버네티스 동작 원리

쿠버네티스에서 애플리케이션을 실행하려면 먼저 하나 이상의 컨테이너 이미지를 레지스트리에 푸시한 후 쿠버네티스 API 서버에 애플리케이션의 디스크립션을 게시해야 합니다.

**Note**: 디스크립션에는 컨테이너 이미지 또는 애플리케이션 컴포넌트가 들어 있는 이미지가 있고, 컴포넌트 간 관련성 및 노드 배치 정보도 포함되며 복제본 수를 지정할 수도 있습니다. 뿐만 아니라 내부 클라이언트나 외부 클라이언트에 서비스를 제공하는 컴포넌트가 들어 있고, 단일 IP 주소로 노출해 다른 컴포넌트에서 검색할 수 있어야 합니다.

스케줄러는 API 서버가 디스크립션을 처리할 때 사용 가능한 워커 노드로 컨테이너의 지정 그룹을 예약합니다. 그런 다음 해당 노드의 Kubelet 은 필요한 컨테이너 이미지를 가져와 컨테이너를 실행하도록 런타임(도커)에 지시합니다. 아래 그림은 이러한 과정을 잘 나타내고 있습니다.

<figure>
  <img src="/media/kubernetes_basic/___.jpeg" alt="" width="600"/>
  <figcaption style="color: grey;">쿠버네티스 아키텍처 & 애플리케이션 실행 과정</figcaption>
</figure>

앱 디스크립터에는 네 개의 컨테이너를 세 개의 세트(포드)로 묶어 나열합니다. 각 포드의 옆에는 병렬로 실행해야 하는 복제본 수를 나타내고 있습니다. 쿠버네티스에 디스크립터를 요청하면, 사용 가능한 워커 노드에 지정된 수의 복제본을 예약합니다. 그런 다음 워커 노드의 kubelet 이 이미지 레지스트리에서 컨테이너 이미지를 가져와 컨테이너를 실행하도록 도커에 알려줍니다.

쿠버네티스는 애플리케이션이 배포된 이후의 상태가 사용자가 제공한 디스크립션과 일치하는지 지속적으로 확인합니다. 만약 특정 인스턴스 중 하나가 제대로 동작하지 않는 경우 자동으로 다시 시작하도록 해줍니다. 또 복사본의 수를 늘릴지, 줄일지를 결정할 수 있으며 최적의 복제본 수를 결정하는 메트릭을 CPU 부하, 메모리 사용량, 초당 쿼리, 그 외 애플리케이션에서 노출하는 메트릭에 따라 자동으로 조절할 수 있습니다.

## 쿠버네티스의 장점

쿠버네티스는 시스템 관리자의 도움 없이 애플리케이션을 실행할 수 있으며, 다음과 같은 장점을 가지고 있습니다.

### 애플리케이션 배포 단순화

쿠버네티스는 모든 워커 노드를 단일 배포 플랫폼으로 제공하므로 개발자가 클러스터를 구성하는 서버에 대해 깊이 들여다 볼 필요를 없애줍니다.

### 높은 하드웨어 활용도

쿠버네티스에 애플리케이션을 실행하도록 지시하면 리소스 요구사항에 대한 설명과 각 노드에서 사용 가능한 리소스에 따라 애플리케이션을 실행할 가장 적합한 노드를 선택하게 됩니다. 또한 클러스터를 중심으로 애플리케이션이 언제든지 이동할 수 있으므로 인프라를 훨씬 효율적으로 활용할 수 있습니다.

### 상태 확인 및 자가 치유

쿠버네티스는 노드에 장애가 발생하면 다른 노드로 일정을 자동으로 재조정합니다. 즉, 운영팀이 수동으로 애플리케이션을 이전하지 않아도 되게 됩니다.

### 오토스케일링

쿠버네티스는 애플리케이션에 급격한 부하가 발생하면 이를 대응하기 위해 전체 클러스터 크기를 자동으로 확대 또는 축소할 수 있습니다.

## Recap

쿠버네티스의 구성요소와 애플리케이션 배포 흐름을 간단하게 살펴보았는데, 배운 내용을 정리하면 다음과 같습니다.

- 쿠버네티스는 전체 데이터 센터를 애플리케이션 실행을 위한 단일 컴퓨팅 리소스로 제공합니다.
- 개발자는 시스템 관리자의 도움 없이 쿠버네티스를 통해 애플리케이션을 배포할 수 있습니다.

## References

- Kubernetes in Action
